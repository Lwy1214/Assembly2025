# 인터프리터

일종의 통역

코드를 한줄씩 읽고 즉시 실행

# 컴파일러

일종의 통역

전체 코드를 한번에 기계어로 번역해서 실행 파일을 만듬

# 파이썬

인터프리터와 컴파일러가 모두 있는 언어 

# 왜 어셈블리어를 배워야 할까?

1. **하드웨어와 소프트웨어의 연결 고리 이해**

- 인간이 읽을수 있는 최소한의 언어형태  (기계어의 인간친화적 표현)
- 어셈블리어는 CPU가 직접 이해하는 **기계어에 가장 가까운 언어**야.
- 이를 배우면 컴퓨터가 명령을 어떻게 처리하는지, 메모리와 레지스터가 어떻게 작동하는지 **깊이 이해**할 수 있어.

2. **시스템 프로그래밍에 필수**

- 운영체제(OS), 컴파일러, 드라이버 같은 **시스템 소프트웨어 개발**에는 어셈블리어가 필수적이야.
- 고급 언어로는 제어하기 어려운 **하드웨어 수준의 작업**을 가능하게 해줘.

3. **성능 최적화**

- 특정 연산이나 반복문에서 **어셈블리어 수준의 최적화**가 필요할 때가 있어.
- 예를 들어, `++i`와 `i++`의 성능 차이를 어셈블리어로 직접 확인할 수 있어.

4. **디버깅과 보안 분석에 유리**

- 디버깅할 때 어셈블리어를 보면 **코드가 실제로 어떻게 실행되는지** 파악할 수 있어.
- 해킹, 리버스 엔지니어링, 악성코드 분석 같은 **보안 분야**에서도 필수적인 언어야.

5. **컴퓨터 구조에 대한 깊은 이해**

- CPU 내부의 **레지스터 구조**, 명령어 처리 방식 등을 배우면서 컴퓨터의 동작 원리를 체감할 수 있어.

# 보수(Complemnent)

## 2의보수(Two’s Complement)

- 숫자 반전 8비트(00000100 → 11111011)
- 거기에 1을 더함 (11111100)

## 2의 보수 원래대로

- 2의보수 한번더 취하면됨

## R의보수

R의 보수: (R−1)의 보수(반전) + 1

✅ 정의

- **(R−1)의 보수에 1을 더한 값**.
- 또는, 해당 수보다 큰 자릿수의 R의 거듭제곱에서 원래 수를 뺀 값.

예: `456`의 10의 보수

→ `1000 − 456 = 544`

→ 또는 `543 + 1 = 544`

## R-1의보수

자리별 반전

✅ 정의

- 어떤 수의 각 자릿수를 **(R−1)에서 뺀 값**으로 구성된 수.
- 예를 들어 10진수에서 `456`의 9의 보수는
→ `999 − 456 = 543`

🔧 계산 방법

1. 해당 수와 같은 자릿수의 최대값(모두 R−1)을 만든다.
2. 그 수에서 원래 수를 뺀다

# 아무진수를 10진수로 변환

- 진수 = x
    - x^0 (일의자리)
    - x^1 (그다음 자리)
    - x^2(그위 자리)
    - ….
    - 

# 2진수를 2^x 진수로 변환

- X개씩 묶어서 계산 , 부족하면 맨 뒤나 앞은 0으로 치고 묶는다
