1. **8비트 이진수에서 최상위 비트(MSB)**
    - MSB는 왼쪽 끝 비트이며 가장 큰 가중치를 갖는 비트입니다.
    - **정답:** 왼쪽 끝 비트 (비트 번호로는 보통 **bit7**).

---

1. **다음 부호 없는(Unsigned) 8비트 이진수들의 10진수 표기**
    - a. `00110101` = 0⋅27+0⋅26+1⋅25+1⋅24+0⋅23+1⋅22+0⋅21+1⋅200\cdot2^7+0\cdot2^6+1\cdot2^5+1\cdot2^4+0\cdot2^3+1\cdot2^2+0\cdot2^1+1\cdot2^00⋅27+0⋅26+1⋅25+1⋅24+0⋅23+1⋅22+0⋅21+1⋅20 = **53**
    - b. `10010110` = **150**
    - c. `11001100` = **204**

---

1. **각 쌍의 이진수 덧셈 (정확한 합과 8비트 결과/오버플로우 정보)**
    
    (아래는 전체 합을 이진/10진으로 표시하고, 8비트로 자른 결과와 오버플로우 여부도 표기합니다.)
    
    - a. `10101111` + `11011011`
        - 합(이진) = `110001010` (9비트) = 394(10진)
        - 8비트로 잘라내면 `10001010` (오버플로우 발생).
        - **결론:** 전체 합 = **394 (이진 `110001010`)**, 8비트 결과 = `10001010` (캐리 발생).
    - b. `10010111` + `11111111`
        - 합(이진) = `110010110` = 406(10진)
        - 8비트로 잘라내면 `10010110` (오버플로우 발생).
        - **결론:** 전체 합 = **406 (이진 `110010110`)**, 8비트 결과 = `10010110` (캐리 발생).
    - c. `01110101` + `10101100`
        - 합(이진) = `100100001` = 289(10진)
        - 8비트로 잘라내면 `00100001` (오버플로우 발생).
        - **결론:** 전체 합 = **289 (이진 `100100001`)**, 8비트 결과 = `00100001` (캐리 발생).
    
    *(문제 의도에 따라 ‘8비트 덧셈 결과’만 요구하면 8비트 결과와 캐리 비트 표시를 사용합니다.)*
    

---

1. **`00001101` − `00000111` (이진)**
    - `00001101`(13) − `00000111`(7) = 6
    - 이진으로: **`00000110`**

---

1. **각 데이터 타입이 사용하는 비트 수**
    
    (일반적인 정의: word = 16비트 기준)
    
    - a. word = **16 bits**
    - b. doubleword = **32 bits**
    - c. quadword = **64 bits**
    - d. double quadword = **128 bits**

---

1. **주어진 부호 없는(Unsigned) 10진수를 표현하는 데 필요한 최소 비트 수**
    
    (필요한 비트 수 = ⌈log⁡2(n+1)⌉\lceil \log_2(n+1)\rceil⌈log2(n+1)⌉)
    
    - a. 4095 → 4095+1=4096=2124095+1=4096 = 2^{12}4095+1=4096=212 → **12비트**
    - b. 65534 → 65534+1=65535<21665534+1=65535 < 2^{16}65534+1=65535<216 이므로 **16비트** (2^16 -1 =65535)
    - c. 42319 → 42319+1=42320<21642319+1=42320 < 2^{16}42319+1=42320<216 → **16비트**

---

1. **다음 이진수들의 16진수 표기 (4비트씩 묶음)**
    - a. `0011 0101 1101 1010` → 그룹마다 4비트 → 3 5 D A → **`35DA`**
    - b. `1100 1110 1010 0011` → C E A 3 → **`CEA3`**
    - c. `1111 1110 1101 1011` → F E D B → **`FEDB`**

---

1. **다음 16진수(8자리)의 2진수 표기 (32비트)**
    - a. `0126F9D4` → **`00000001001001101111100111010100`**
    - b. `6ACDFA95` → **`01101010110011011111101010010101`**
    - c. `F69BDC2A` → **`11110110100110111101110000101010`**

---

1. **다음 16진수의 부호 없는 10진수 값**
    - a. `3A` (16진) = **58**
    - b. `1BF` = **447**
    - c. `1001` = **4097**

---

1. **다음 16진수의 부호 없는 10진수 값**
- a. `62` = **98**
- b. `4B3` = **1203**
- c. `29F` = **671**

---

1. **다음 부호 있는(signed) 10진수를 16비트 16진수(2의 보수)로 표기**
- a. −24 → 16비트 2의 보수 = **`FFE8`**
    
    (검산: `FFE8` = 65512 unsigned → 65512 − 65536 = −24)
    
- b. −331 → **`FEB5`**

---

1. **다음 부호 있는 10진수 → 16비트 16진수 (2의 보수)**
- a. −21 → **`FFEB`**
- b. −45 → **`FFD3`**

---

1. **주어진 16비트 16진수가 나타내는 부호 있는 정수 (10진수)**
- a. `6BF9` → 최상위 비트 0 → 양수 → 16진 `6BF9` = **27641**
- b. `C123` → 최상위 비트 1 → 음수 → 값 = `C123`(unsigned 49443) − 65536 = **−16093**

---

1. **다음 16비트 16진수 → 부호 있는 10진수**
- a. `4CD2` → MSB 0 → 양수 → **19666**
- b. `8230` → MSB 1 → 음수 → `8230`(unsigned 33328) − 65536 = **−32208**

---

1. **다음 8비트 이진(2의 보수) → 10진수 (부호 있는)**
- a. `10110101` → 음수 → 값 = 0xB5 = 181 → 181−256 = **−75**
- b. `00101010` → MSB 0 → **42**
- c. `11110000` → 음수 → 0xF0 = 240 → 240−256 = **−16**

---

1. **다음 8비트 이진(2의 보수) → 10진수 (부호 있는)**
- a. `10000000` → 0x80 = 128 → 128−256 = **−128**
- b. `11001100` → 0xCC = 204 → 204−256 = **−52**
- c. `10110111` → 0xB7 = 183 → 183−256 = **−73**

---

1. **다음 부호 있는 10진수를 8비트(2의 보수) 이진수로**

(음수는 2의 보수 표현)

- a. −5 → **`11111011`**
- b. −42 → **`11010110`**
- c. −16 → **`11110000`**

---

1. **다음 부호 있는 10진수 → 8비트 2의 보수**
- a. −72 → **`10111000`**
- b. −98 → **`10011110`**
- c. −26 → **`11100110`**

---

1. **각 16진수 쌍의 합**
- a. `6B4` + `3FE` = 0x6B4 (1716) + 0x3FE (1022) = 2738 = **`AB2`** (16진)
- b. `A49` + `6BD` = 0xA49 (2633) + 0x6BD (1725) = 4358 = **`1106`** (16진)
