# 1.7 문제풀이


1. **8비트 이진수에서 최상위 비트(MSB)**
    - MSB는 왼쪽 끝 비트이며 가장 큰 가중치를 갖는 비트입니다.
    - **정답:** 왼쪽 끝 비트 (비트 번호로는 보통 **bit7**).

---

2. **다음 부호 없는(Unsigned) 8비트 이진수들의 10진수 표기**
    - a. `00110101` = 0⋅27+0⋅26+1⋅25+1⋅24+0⋅23+1⋅22+0⋅21+1⋅200\cdot2^7+0\cdot2^6+1\cdot2^5+1\cdot2^4+0\cdot2^3+1\cdot2^2+0\cdot2^1+1\cdot2^00⋅27+0⋅26+1⋅25+1⋅24+0⋅23+1⋅22+0⋅21+1⋅20 = **53**
    - b. `10010110` = **150**
    - c. `11001100` = **204**

---

3. **각 쌍의 이진수 덧셈 (정확한 합과 8비트 결과/오버플로우 정보)**
    
    (아래는 전체 합을 이진/10진으로 표시하고, 8비트로 자른 결과와 오버플로우 여부도 표기합니다.)
    
    - a. `10101111` + `11011011`
        - 합(이진) = `110001010` (9비트) = 394(10진)
        - 8비트로 잘라내면 `10001010` (오버플로우 발생).
        - **결론:** 전체 합 = **394 (이진 `110001010`)**, 8비트 결과 = `10001010` (캐리 발생).
    - b. `10010111` + `11111111`
        - 합(이진) = `110010110` = 406(10진)
        - 8비트로 잘라내면 `10010110` (오버플로우 발생).
        - **결론:** 전체 합 = **406 (이진 `110010110`)**, 8비트 결과 = `10010110` (캐리 발생).
    - c. `01110101` + `10101100`
        - 합(이진) = `100100001` = 289(10진)
        - 8비트로 잘라내면 `00100001` (오버플로우 발생).
        - **결론:** 전체 합 = **289 (이진 `100100001`)**, 8비트 결과 = `00100001` (캐리 발생).
    
    *(문제 의도에 따라 ‘8비트 덧셈 결과’만 요구하면 8비트 결과와 캐리 비트 표시를 사용합니다.)*
    

---

4. **`00001101` − `00000111` (이진)**
    - `00001101`(13) − `00000111`(7) = 6
    - 이진으로: **`00000110`**

---

5. **각 데이터 타입이 사용하는 비트 수**
    
    (일반적인 정의: word = 16비트 기준)
    
    - a. word = **16 bits**
    - b. doubleword = **32 bits**
    - c. quadword = **64 bits**
    - d. double quadword = **128 bits**

---

6. **주어진 부호 없는(Unsigned) 10진수를 표현하는 데 필요한 최소 비트 수**
    
    (필요한 비트 수 = ⌈log⁡2(n+1)⌉\lceil \log_2(n+1)\rceil⌈log2(n+1)⌉)
    
    - a. 4095 → 4095+1=4096=2124095+1=4096 = 2^{12}4095+1=4096=212 → **12비트**
    - b. 65534 → 65534+1=65535<21665534+1=65535 < 2^{16}65534+1=65535<216 이므로 **16비트** (2^16 -1 =65535)
    - c. 42319 → 42319+1=42320<21642319+1=42320 < 2^{16}42319+1=42320<216 → **16비트**

---

7. **다음 이진수들의 16진수 표기 (4비트씩 묶음)**
    - a. `0011 0101 1101 1010` → 그룹마다 4비트 → 3 5 D A → **`35DA`**
    - b. `1100 1110 1010 0011` → C E A 3 → **`CEA3`**
    - c. `1111 1110 1101 1011` → F E D B → **`FEDB`**

---

8. **다음 16진수(8자리)의 2진수 표기 (32비트)**
    - a. `0126F9D4` → **`00000001001001101111100111010100`**
    - b. `6ACDFA95` → **`01101010110011011111101010010101`**
    - c. `F69BDC2A` → **`11110110100110111101110000101010`**

---

9. **다음 16진수의 부호 없는 10진수 값**
    - a. `3A` (16진) = **58**
    - b. `1BF` = **447**
    - c. `1001` = **4097**

---

10. **다음 16진수의 부호 없는 10진수 값**
- a. `62` = **98**
- b. `4B3` = **1203**
- c. `29F` = **671**

---

11. **다음 부호 있는(signed) 10진수를 16비트 16진수(2의 보수)로 표기**
- a. −24 → 16비트 2의 보수 = **`FFE8`**
    
    (검산: `FFE8` = 65512 unsigned → 65512 − 65536 = −24)
    
- b. −331 → **`FEB5`**

---

12. **다음 부호 있는 10진수 → 16비트 16진수 (2의 보수)**
- a. −21 → **`FFEB`**
- b. −45 → **`FFD3`**

---

13. **주어진 16비트 16진수가 나타내는 부호 있는 정수 (10진수)**
- a. `6BF9` → 최상위 비트 0 → 양수 → 16진 `6BF9` = **27641**
- b. `C123` → 최상위 비트 1 → 음수 → 값 = `C123`(unsigned 49443) − 65536 = **−16093**

---

14. **다음 16비트 16진수 → 부호 있는 10진수**
- a. `4CD2` → MSB 0 → 양수 → **19666**
- b. `8230` → MSB 1 → 음수 → `8230`(unsigned 33328) − 65536 = **−32208**

---

15. **다음 8비트 이진(2의 보수) → 10진수 (부호 있는)**
- a. `10110101` → 음수 → 값 = 0xB5 = 181 → 181−256 = **−75**
- b. `00101010` → MSB 0 → **42**
- c. `11110000` → 음수 → 0xF0 = 240 → 240−256 = **−16**

---

16. **다음 8비트 이진(2의 보수) → 10진수 (부호 있는)**
- a. `10000000` → 0x80 = 128 → 128−256 = **−128**
- b. `11001100` → 0xCC = 204 → 204−256 = **−52**
- c. `10110111` → 0xB7 = 183 → 183−256 = **−73**

---

17. **다음 부호 있는 10진수를 8비트(2의 보수) 이진수로**

(음수는 2의 보수 표현)

- a. −5 → **`11111011`**
- b. −42 → **`11010110`**
- c. −16 → **`11110000`**

---

18. **다음 부호 있는 10진수 → 8비트 2의 보수**
- a. −72 → **`10111000`**
- b. −98 → **`10011110`**
- c. −26 → **`11100110`**

---

19. **각 16진수 쌍의 합**
- a. `6B4` + `3FE` = 0x6B4 (1716) + 0x3FE (1022) = 2738 = **`AB2`** (16진)
- b. `A49` + `6BD` = 0xA49 (2633) + 0x6BD (1725) = 4358 = **`1106`** (16진)

---

20. **각 16진수 쌍의 합**
    
    (각 항을 16진 → 10진 변환 후 더하고 다시 16진으로 표기)
    

a. `7C4` + `3BE`

- `7C4`(16) = 7×16² + 12×16 + 4 = 7×256 + 12×16 + 4 = 1792 + 192 + 4 = 1988
- `3BE`(16) = 3×256 + 11×16 + 14 = 768 + 176 + 14 = 958
- 합 = 1988 + 958 = 2946
- 16진 표기 = **`B82`**
- **정답:** `B82` (10진 2946)

b. `B69` + `7AD`

- `B69`(16) = 11×256 + 6×16 + 9 = 2816 + 96 + 9 = 291; wait 계산검사 → (다시) 11×256=2816, +96=2912, +9=2921.
- `7AD`(16) = 7×256 + 10×16 + 13 = 1792 + 160 + 13 = 1965
- 합 = 2921 + 1965 = 4886
- 16진 표기 = **`1316`**
- **정답:** `1316` (10진 4886)

---

21. **ASCII 문자 'B'의 16진 및 10진 값**
- 문자 `'B'`의 ASCII 코드 = **10진 66**
- 16진 표기 = **`0x42`**

---

22. **ASCII 문자 'G'의 16진 및 10진 값**
- 문자 `'G'`의 ASCII 코드 = **10진 71**
- 16진 표기 = **`0x47`**

---

23. **도전문제: 129비트 부호 없는(unsigned) 정수로 표현 가능한 최대 10진값**
- 부호 없는 n비트의 최대값 = 2n−12^n - 12n−1 이므로, 129비트의 최대값 = 2129−12^{129} - 12129−1.
- 계산 결과(십진) = **680564733841876926926749214863536422911**
- 16진으로는 2129−12^{129}-12129−1 이므로 129비트 모두 1인 값입니다.

---

24. **도전문제: 86비트 부호 있는(signed) 정수로 표현 가능한 최대 10진값**
- 일반적인 2의 보수 표현에서 n비트 signed의 최대값 = 2(n−1)−12^{(n-1)} - 12(n−1)−1.
- 따라서 86비트 signed의 최대값 = 285−12^{85} - 1285−1.
- 계산 결과(십진) = **38685626227668133590597631**

---

# 25. ¬(A ∨ B) 의 진리표

A와 B의 모든 조합에 대해 A ∨ B 와 그 부정 ¬(A ∨ B)를 계산하면:

| A | B | A ∨ B | ¬(A ∨ B) |
| --- | --- | --- | --- |
| 0 | 0 | 0 | 1 |
| 0 | 1 | 1 | 0 |
| 1 | 0 | 1 | 0 |
| 1 | 1 | 1 | 0 |

(여기서 0 = false, 1 = true)

---

# 26. (¬A ∧ ¬B) 의 진리표 및 25번과의 관계

먼저 (¬A ∧ ¬B) 의 진리표:

| A | B | ¬A | ¬B | ¬A ∧ ¬B |
| --- | --- | --- | --- | --- |
| 0 | 0 | 1 | 1 | 1 |
| 0 | 1 | 1 | 0 | 0 |
| 1 | 0 | 0 | 1 | 0 |
| 1 | 1 | 0 | 0 | 0 |

비교하면 오른쪽 열(¬A ∧ ¬B)은 25번의 ¬(A ∨ B) 의 오른쪽 열과 **완전히 동일**합니다.

이것이 바로 **드모르간(De Morgan)의 정리** 입니다:

¬(A∨B)≡(¬A)∧(¬B)\neg (A \lor B) \equiv (\neg A) \land (\neg B)

¬(A∨B)≡(¬A)∧(¬B)

(또한 ¬(A∧B)≡(¬A)∨(¬B)\neg(A \land B) \equiv (\neg A) \lor (\neg B)¬(A∧B)≡(¬A)∨(¬B) 도 성립)

---

# 27. 입력이 4개인 불 함수의 진리표 행 수

입력이 nnn개이면 가능한 입력 조합 수는 2n2^n2n개입니다.

따라서 n=4n=4n=4이면 행 수는 24=162^4 = \mathbf{16}24=16 행입니다.

---

# 28. 4-입력 멀티플렉서에 필요한 선택 비트 수

멀티플렉서의 선택비트(s) 개수는 2s2^s2s가 입력 개수와 같아야 합니다.

입력 4개이므로 2s=42^s = 42s=4 → s=2s = 2s=2.

따라서 **2개의 선택 비트**가 필요합니다.

---
## 📌 2. Algorithm Workbench (1.7.2)

### 1번

**16비트 이진 문자열 → 정수 변환 함수**

```python
def bin16_to_int(bin_str):
    return int(bin_str, 2)

print(bin16_to_int("0000000000010101"))  # 21

```

---

### 2번

**32비트 16진 문자열 → 정수 변환 함수**

```python
def hex32_to_int(hex_str):
    return int(hex_str, 16)

print(hex32_to_int("000000FF"))  # 255

```

---

### 3번

**정수 → 이진 문자열 변환**

```python
def int_to_bin(num):
    return bin(num)[2:]

print(int_to_bin(21))  # "10101"

```

---

### 4번

**정수 → 16진 문자열 변환**

```python
def int_to_hex(num):
    return hex(num)[2:].upper()

print(int_to_hex(255))  # "FF"

```

---

### 5번

**두 수(base b, 최대 1000자리) 덧셈**

```python
def add_base_b(num1, num2, b):
    n1 = int(num1, b)
    n2 = int(num2, b)
    return format(n1 + n2, 'b' if b==2 else '').upper()

# 예시 (base 10)
print(add_base_b("123", "456", 10))  # "579"
# 예시 (base 2)
print(add_base_b("1010", "1111", 2))  # "11001"

```

---

### 6번

**두 개의 긴 16진 문자열 덧셈**

```python
def add_hex_strings(h1, h2):
    n1 = int(h1, 16)
    n2 = int(h2, 16)
    return hex(n1 + n2)[2:].upper()

print(add_hex_strings("ABC", "123"))  # "BDF"

```

---

### 7번

**한 자리 16진수 × 긴 16진수**

```python
def multiply_hex(digit, hex_str):
    d = int(digit, 16)
    n = int(hex_str, 16)
    return hex(d * n)[2:].upper()

print(multiply_hex("A", "123"))  # "B58"

```
## 📌 1. Chapter Questions

### 문제 8

**문제:**

```java
int Y;
int X = (Y + 4) * 3;

```

을 포함하는 Java 프로그램 작성 후 `javap -c`로 디스어셈블하고, 각 명령어의 역할을 추측.

**풀이 예시 (Java 코드):**

```java
public class CalcTest {
    public static void main(String[] args) {
        int Y = 5;            // Y에 예시 값 저장
        int X = (Y + 4) * 3;  // 계산식
        System.out.println(X);
    }
}

```

**실행 결과:**

Y=5 → X = (5+4)*3 = 27

**디스어셈블 (`javap -c CalcTest` 예상 결과):**

```
0: iconst_5        // 정수 5 스택에 push
1: istore_1        // 지역변수 Y에 저장
2: iload_1         // Y 로드
3: iconst_4        // 상수 4 push
4: iadd            // Y+4
5: iconst_3        // 상수 3 push
6: imul            // (Y+4)*3
7: istore_2        // 결과를 X에 저장

```

**해설:**

- `iconst` = 상수 로드
- `iload` = 변수 로드
- `iadd` = 정수 덧셈
- `imul` = 정수 곱셈
- `istore` = 변수에 저장

즉, 바이트코드가 Java의 산술 연산 과정을 스택 기반으로 수행함을 보여줌.

---

### 문제 9

**문제:**

Unsigned binary subtraction 방법 고안하기.

예: `10001000 - 00000101 = 10000011`

**풀이:**

Unsigned 뺄셈은 **2의 보수 덧셈법**을 사용한다.

1. 뺄셈할 값(피감수)의 보수를 구한다.
2. 덧셈을 수행한다.
3. 최상위 캐리가 발생하면 버린다.

**예제 1:**

```
10001000 (136)
- 00000101 (5)

→ 5의 2의 보수 = 11111011
136 + 251 = 387
8비트 결과 = 10000011 (decimal 131)

```

정답: `10000011`

**다른 예제 2:**

```
01101010 (106)
- 00001001 (9)

→ 9의 2의 보수 = 11110111
106 + 247 = 353
8비트 결과 = 10110001 (decimal 177)

```

**다른 예제 3:**

```
11110000 (240)
- 00001111 (15)

→ 15의 2의 보수 = 11110001
240 + 241 = 481
8비트 결과 = 11100001 (decimal 225)

```
