1. **8비트 이진수에서 최상위 비트(MSB)**
    - MSB는 왼쪽 끝 비트이며 가장 큰 가중치를 갖는 비트입니다.
    - **정답:** 왼쪽 끝 비트 (비트 번호로는 보통 **bit7**).

---

2. **다음 부호 없는(Unsigned) 8비트 이진수들의 10진수 표기**
    - a. `00110101` = 0⋅27+0⋅26+1⋅25+1⋅24+0⋅23+1⋅22+0⋅21+1⋅200\cdot2^7+0\cdot2^6+1\cdot2^5+1\cdot2^4+0\cdot2^3+1\cdot2^2+0\cdot2^1+1\cdot2^00⋅27+0⋅26+1⋅25+1⋅24+0⋅23+1⋅22+0⋅21+1⋅20 = **53**
    - b. `10010110` = **150**
    - c. `11001100` = **204**

---

3. **각 쌍의 이진수 덧셈 (정확한 합과 8비트 결과/오버플로우 정보)**
    
    (아래는 전체 합을 이진/10진으로 표시하고, 8비트로 자른 결과와 오버플로우 여부도 표기합니다.)
    
    - a. `10101111` + `11011011`
        - 합(이진) = `110001010` (9비트) = 394(10진)
        - 8비트로 잘라내면 `10001010` (오버플로우 발생).
        - **결론:** 전체 합 = **394 (이진 `110001010`)**, 8비트 결과 = `10001010` (캐리 발생).
    - b. `10010111` + `11111111`
        - 합(이진) = `110010110` = 406(10진)
        - 8비트로 잘라내면 `10010110` (오버플로우 발생).
        - **결론:** 전체 합 = **406 (이진 `110010110`)**, 8비트 결과 = `10010110` (캐리 발생).
    - c. `01110101` + `10101100`
        - 합(이진) = `100100001` = 289(10진)
        - 8비트로 잘라내면 `00100001` (오버플로우 발생).
        - **결론:** 전체 합 = **289 (이진 `100100001`)**, 8비트 결과 = `00100001` (캐리 발생).
    
    *(문제 의도에 따라 ‘8비트 덧셈 결과’만 요구하면 8비트 결과와 캐리 비트 표시를 사용합니다.)*
    

---

4. **`00001101` − `00000111` (이진)**
    - `00001101`(13) − `00000111`(7) = 6
    - 이진으로: **`00000110`**

---

5. **각 데이터 타입이 사용하는 비트 수**
    
    (일반적인 정의: word = 16비트 기준)
    
    - a. word = **16 bits**
    - b. doubleword = **32 bits**
    - c. quadword = **64 bits**
    - d. double quadword = **128 bits**

---

6. **주어진 부호 없는(Unsigned) 10진수를 표현하는 데 필요한 최소 비트 수**
    
    (필요한 비트 수 = ⌈log⁡2(n+1)⌉\lceil \log_2(n+1)\rceil⌈log2(n+1)⌉)
    
    - a. 4095 → 4095+1=4096=2124095+1=4096 = 2^{12}4095+1=4096=212 → **12비트**
    - b. 65534 → 65534+1=65535<21665534+1=65535 < 2^{16}65534+1=65535<216 이므로 **16비트** (2^16 -1 =65535)
    - c. 42319 → 42319+1=42320<21642319+1=42320 < 2^{16}42319+1=42320<216 → **16비트**

---

7. **다음 이진수들의 16진수 표기 (4비트씩 묶음)**
    - a. `0011 0101 1101 1010` → 그룹마다 4비트 → 3 5 D A → **`35DA`**
    - b. `1100 1110 1010 0011` → C E A 3 → **`CEA3`**
    - c. `1111 1110 1101 1011` → F E D B → **`FEDB`**

---

8. **다음 16진수(8자리)의 2진수 표기 (32비트)**
    - a. `0126F9D4` → **`00000001001001101111100111010100`**
    - b. `6ACDFA95` → **`01101010110011011111101010010101`**
    - c. `F69BDC2A` → **`11110110100110111101110000101010`**

---

9. **다음 16진수의 부호 없는 10진수 값**
    - a. `3A` (16진) = **58**
    - b. `1BF` = **447**
    - c. `1001` = **4097**

---

10. **다음 16진수의 부호 없는 10진수 값**
- a. `62` = **98**
- b. `4B3` = **1203**
- c. `29F` = **671**

---

11. **다음 부호 있는(signed) 10진수를 16비트 16진수(2의 보수)로 표기**
- a. −24 → 16비트 2의 보수 = **`FFE8`**
    
    (검산: `FFE8` = 65512 unsigned → 65512 − 65536 = −24)
    
- b. −331 → **`FEB5`**

---

12. **다음 부호 있는 10진수 → 16비트 16진수 (2의 보수)**
- a. −21 → **`FFEB`**
- b. −45 → **`FFD3`**

---

13. **주어진 16비트 16진수가 나타내는 부호 있는 정수 (10진수)**
- a. `6BF9` → 최상위 비트 0 → 양수 → 16진 `6BF9` = **27641**
- b. `C123` → 최상위 비트 1 → 음수 → 값 = `C123`(unsigned 49443) − 65536 = **−16093**

---

14. **다음 16비트 16진수 → 부호 있는 10진수**
- a. `4CD2` → MSB 0 → 양수 → **19666**
- b. `8230` → MSB 1 → 음수 → `8230`(unsigned 33328) − 65536 = **−32208**

---

15. **다음 8비트 이진(2의 보수) → 10진수 (부호 있는)**
- a. `10110101` → 음수 → 값 = 0xB5 = 181 → 181−256 = **−75**
- b. `00101010` → MSB 0 → **42**
- c. `11110000` → 음수 → 0xF0 = 240 → 240−256 = **−16**

---

16. **다음 8비트 이진(2의 보수) → 10진수 (부호 있는)**
- a. `10000000` → 0x80 = 128 → 128−256 = **−128**
- b. `11001100` → 0xCC = 204 → 204−256 = **−52**
- c. `10110111` → 0xB7 = 183 → 183−256 = **−73**

---

17. **다음 부호 있는 10진수를 8비트(2의 보수) 이진수로**

(음수는 2의 보수 표현)

- a. −5 → **`11111011`**
- b. −42 → **`11010110`**
- c. −16 → **`11110000`**

---

18. **다음 부호 있는 10진수 → 8비트 2의 보수**
- a. −72 → **`10111000`**
- b. −98 → **`10011110`**
- c. −26 → **`11100110`**

---

19. **각 16진수 쌍의 합**
- a. `6B4` + `3FE` = 0x6B4 (1716) + 0x3FE (1022) = 2738 = **`AB2`** (16진)
- b. `A49` + `6BD` = 0xA49 (2633) + 0x6BD (1725) = 4358 = **`1106`** (16진)

---

20. **각 16진수 쌍의 합**
    
    (각 항을 16진 → 10진 변환 후 더하고 다시 16진으로 표기)
    

a. `7C4` + `3BE`

- `7C4`(16) = 7×16² + 12×16 + 4 = 7×256 + 12×16 + 4 = 1792 + 192 + 4 = 1988
- `3BE`(16) = 3×256 + 11×16 + 14 = 768 + 176 + 14 = 958
- 합 = 1988 + 958 = 2946
- 16진 표기 = **`B82`**
- **정답:** `B82` (10진 2946)

b. `B69` + `7AD`

- `B69`(16) = 11×256 + 6×16 + 9 = 2816 + 96 + 9 = 291; wait 계산검사 → (다시) 11×256=2816, +96=2912, +9=2921.
- `7AD`(16) = 7×256 + 10×16 + 13 = 1792 + 160 + 13 = 1965
- 합 = 2921 + 1965 = 4886
- 16진 표기 = **`1316`**
- **정답:** `1316` (10진 4886)

---

21. **ASCII 문자 'B'의 16진 및 10진 값**
- 문자 `'B'`의 ASCII 코드 = **10진 66**
- 16진 표기 = **`0x42`**

---

22. **ASCII 문자 'G'의 16진 및 10진 값**
- 문자 `'G'`의 ASCII 코드 = **10진 71**
- 16진 표기 = **`0x47`**

---

23. **도전문제: 129비트 부호 없는(unsigned) 정수로 표현 가능한 최대 10진값**
- 부호 없는 n비트의 최대값 = 2n−12^n - 12n−1 이므로, 129비트의 최대값 = 2129−12^{129} - 12129−1.
- 계산 결과(십진) = **680564733841876926926749214863536422911**
- 16진으로는 2129−12^{129}-12129−1 이므로 129비트 모두 1인 값입니다.

---

24. **도전문제: 86비트 부호 있는(signed) 정수로 표현 가능한 최대 10진값**
- 일반적인 2의 보수 표현에서 n비트 signed의 최대값 = 2(n−1)−12^{(n-1)} - 12(n−1)−1.
- 따라서 86비트 signed의 최대값 = 285−12^{85} - 1285−1.
- 계산 결과(십진) = **38685626227668133590597631**
